(in-package CL-LIB)(cl-lib:version-reporter "CL-LIB-String-io-streams" 5 0 ";; Time-stamp: <2007-05-18 11:29:41 miller>"                          "CVS: $Id: string-io-stream.lisp,v 1.1.1.1 2007/11/19 17:48:12 gorbag Exp $restructured version");;; ****************************************************************;;; String I/O Streams  ********************************************;;; ****************************************************************;;;;;; This is the string I/O Streams package written May 1994 by ;;;   Bradford W. Miller;;;   miller@cs.rochester.edu;;;   University of Rochester, Department of Computer Science;;;   610 CS Building, Comp Sci Dept., U. Rochester, Rochester NY 14627-0226;;;   716-275-1118;;; I will be glad to respond to bug reports or feature requests.;;; (please note I am no longer at that address);;;;;; This version was NOT obtained from the directory;;; /afs/cs.cmu.edu/user/mkant/Public/Lisp-Utilities/initializations.lisp;;; via anonymous ftp from a.gp.cs.cmu.edu. (you got it in cl-lib).;;;;;; Copyright (C) 1994 by Bradford W. Miller, miller@cs.rochester.edu ;;;                       and the Trustees of the University of Rochester;;; All rights reserved.;;; Right of use & redistribution is granted as per the terms of the ;;; GNU LIBRARY GENERAL PUBLIC LICENCE version 2 which is incorporated here by;;; reference. ;;;;;; This library is distributed in the hope that it will be useful,;;; but WITHOUT ANY WARRANTY; without even the implied warranty of;;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the;;; GNU Library General Public License for more details.;;;;;; You should have received a copy of the GNU Library General Public License;;; along with this program; if not, write to the Free Software;;; Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.;;;;; this depends on the allegro process and stream stuff, but should be simple to port.;;; A common need for streams is to act as a delay, and for IPC. This package implements a simple single-writer ;;; multiple-reader stream for characters. The producer and each consumer is expected to be in their own process,;;; that is, have a unique binding of mp:*current-process*.(defclass-x string-io-stream (stream:fundamental-input-stream stream:fundamental-output-stream stream:fundamental-character-stream)  ((buffer :initform (make-array '(200) :fill-pointer 0 :adjustable t :element-type 'character :initial-element #\space) :type vector :accessor sios-buffer)   (objects :initform nil :type list :accessor sios-objects)   (proc-pointer-alist :initform nil :type alist :accessor sios-proc-pointer-alist)   (writer-proc :initform mp:*current-process* :reader sios-writer-proc :initarg :writer-proc)   (eof-p :initform nil :type symbol :accessor sios-eof-p))  )(defgeneric flush-stream-buffer (stream)  (:documentation "Flush the buffer in stream, usually after a commit has occured.Allows us to gc the stream buffers, objects, etc.Note that anyone who starts to read or rewind stream will only see things written afterthe flush."))(defgeneric get-posn (stream))(defmethod get-posn ((stream string-io-stream))  (cond   ((verify-writer stream nil)    (fill-pointer (sios-buffer stream)))   ((cdr (assoc MP:*CURRENT-PROCESS* (sios-proc-pointer-alist stream))))   ;; new reader   (t    (update-alist mp:*current-process* 0 (sios-proc-pointer-alist stream))    0)))(defsetf get-posn (stream) (new-posn)  `(unless (and (string-io-stream-mw-p ,stream)                (assoc mp:*current-process* (sios-wbufs ,stream))) ; ignore writer posn     (setf (cdr (assoc MP:*CURRENT-PROCESS* (sios-proc-pointer-alist ,stream))) ,new-posn)))(defgeneric verify-writer (stream error-p))(defmethod verify-writer ((stream string-io-stream) error-p)  (cond   ((equal mp:*current-process* (sios-writer-proc stream)))   (error-p    (error "Attempt to write to string-io-stream by a reader proc"))))(defgeneric stream-input-available-p (stream))(defmethod stream-input-available-p ((stream t))  (if (interactive-stream-p stream)      (stream:stream-listen stream)    t))(defmethod stream-input-available-p ((stream string-io-stream))  (let ((posn (get-posn stream)))    (or (sios-eof-p stream)        (< posn (fill-pointer (sios-buffer stream))))))(defmethod stream:stream-read-char ((stream string-io-stream))  (let ((posn (get-posn stream)))    (labels ((input-available (wait-fn)               (declare (ignore wait-fn))               (stream-input-available-p stream)))      (while-not (input-available nil)        (mp:wait-for-input-available          stream          :whostate "Stream Char Wait"         :wait-function #'input-available)))    (if (>= posn (fill-pointer (sios-buffer stream))) ; must have been at :eof, else we'd still be waiting.        :eof      (prog1 (aref (sios-buffer stream) posn)        (incf (get-posn stream))))))(defmethod stream:stream-unread-char ((stream string-io-stream) char)  (let ((posn (1- (get-posn stream))))    (unless (eql (aref (sios-buffer stream) posn) char)      (error "Attempt to unread char ~C, but last character read was ~C." char (aref (sios-buffer stream) posn)))    (setf (get-posn stream) posn)))(defmethod stream:stream-read-char-no-hang ((stream string-io-stream))  (if (or (sios-eof-p stream)          (stream:stream-listen stream))      (stream:stream-read-char stream)))(defmethod stream:stream-listen ((stream string-io-stream))  (< (get-posn stream) (fill-pointer (sios-buffer stream))))(defmethod stream:stream-write-char ((stream string-io-stream) character)  (verify-writer stream t)  (vector-push-extend character (sios-buffer stream)))(defmethod stream:stream-terpri ((stream string-io-stream))  (stream:stream-write-char stream #\newline))(defmethod stream:stream-line-column ((stream string-io-stream))  (let* ((posn (get-posn stream))         (rel-posn 0)         (rel-ptr (1- posn)))    (cond     ((zerop posn)      0)     (t      (while-not (zerop rel-ptr)        (when (eql (aref (sios-buffer stream) rel-ptr) #\newline)          (return-from stream:stream-line-column rel-posn))        (incf rel-posn)        (decf rel-ptr))      rel-posn))))(defmethod stream:stream-start-line-p ((stream string-io-stream))  (zerop (stream:stream-line-column stream)))(defmethod stream:stream-write-string ((stream string-io-stream) string &optional start end)  (sios-sws-internal stream string start end))  (defun sios-sws-internal (stream string start end)  (let ((start (or start 0))        (end (or end (length string))))    (verify-writer stream t)    (let* ((posn (fill-pointer (sios-buffer stream)))           (new-fill (- (+ posn end) start))           (temp start)           (needed-increase (- new-fill (array-dimension (sios-buffer stream) 0))))      (when (plusp needed-increase)        (adjust-array (sios-buffer stream) (list new-fill)                      :element-type 'character))      (while (< posn new-fill)        (setf (elt (sios-buffer stream) posn) (elt string temp))        (incf posn)        (incf temp))      (setf (fill-pointer (sios-buffer stream)) posn))    string))(defmethod stream:stream-read-line ((stream string-io-stream))  (let* ((posn (get-posn stream))         next-newline)    (labels ((input-available (wait-fn)               (declare (ignore wait-fn))               (or (sios-eof-p stream)                   (setq next-newline (position #\newline (sios-buffer stream) :start posn)))))      (while-not (input-available nil)        (mp:wait-for-input-available          stream          :whostate "Stream Line Wait"         :wait-function #'input-available)))    (cond     (next-newline      (incf next-newline)      (setf (get-posn stream) next-newline)      (values (subseq (sios-buffer stream) posn next-newline) nil))     (t      (setf (get-posn stream) (fill-pointer (sios-buffer stream)))      (values (subseq (sios-buffer stream) posn) t)))));; eventually want to specialize these to make protocol more efficient.;;(defmethod stream:stream-read-sequence ((stream string-io-stream) sequence &optional start end);;  );;(defmethod stream:stream-write-sequence ((stream string-io-stream) sequence &optional start end);;  )(defmethod close ((stream string-io-stream) &key abort)  (declare (ignore abort))  (when (verify-writer stream nil)    (setf (sios-eof-p stream) t))  (call-next-method));; a more complete version of the above, that allows multiple writers and readers. Note that this uses a locking protocol;; to protect the writers from each other. Two processes simultaneously writing are not guarenteed a specific output order,;; only that each write (a string terminated with a newline) will be atomic, i.e. they won't be garbled. ;; a single process may both read and write, but should avoid reading until closing out the current record (otherwise the results;; may not be what is expected!) Reads will always be from the last read (0 start), and writes will always;; be to the end.;; Note that the close protocol is such that if there are no known writers (who have not closed the stream), then the stream;; will have an EOF mark added to the end. It is important, then, if there are to be multiple writers that some writer;; keep the stream open until you really want it closed. write1 write2 - close1 close2 - write3 will get an error, since;; write3 is too late, but write1 write2 - close1 - write3 - close2 would have been ok, since we'd know process 3 would;; be a writer so the close2 doesn't really close the stream.;; by the same token, if you close the stream, you can still read and write to it if it isn't really closed. Writing to it;; does prevent someone else from really closing it until you close it again. Obviously this is all moot unless you are;; using these streams for some pathological cases :-)(defclass-x string-io-stream-mw (string-io-stream)  ;; have a separate buffer for each writer.  ((write-buffers :initform nil :type alist :accessor sios-wbufs))  )(defmethod verify-writer ((stream string-io-stream-mw) error-p)  (declare (ignore error-p))  t)                                    ; any stream can write.(defmethod get-posn ((stream string-io-stream-mw))  (let ((current-writer (assoc mp:*current-process* (sios-wbufs stream))))    (cond     ((cdr current-writer)      (fill-pointer (cdr current-writer)))     ((cdr (assoc MP:*CURRENT-PROCESS* (sios-proc-pointer-alist stream))))     ;; new reader     (t      (update-alist mp:*current-process* 0 (sios-proc-pointer-alist stream))      0))))(defmethod stream:stream-write-char ((stream string-io-stream-mw) character)  (let ((current-writer (assoc mp:*current-process* (sios-wbufs stream))))    (cond     ((cdr current-writer)      (vector-push-extend character (cdr current-writer)))     ((eql character #\newline)      (error "Bogus empty record to string-io-stream-mw"))     (t      (update-alist mp:*current-process* (make-array '(20) :fill-pointer 1 :adjustable t :element-type 'character :initial-element character) (sios-wbufs stream))      (setf current-writer (assoc mp:*current-process* (sios-wbufs stream)))))    ;; handle copying to main buffer if record done.    (if (eql character #\newline)        (process:without-preemption         (sios-sws-internal stream (cdr current-writer) 0 (fill-pointer (cdr current-writer)))         (setf (cdr current-writer) nil)))))(defmethod stream:stream-line-column ((stream string-io-stream-mw))  (let ((current-writer (assoc mp:*current-process* (sios-wbufs stream))))    (if (cdr current-writer)        (get-posn stream)               ; position in the write buffer      (call-next-method))))(defmethod stream:stream-write-string ((stream string-io-stream-mw) string &optional start end)  ;; if there are any newline characters in the string, handle specially.  (let ((current-start (or start 0))        current-newline        (end (or end (length string))))    (while (setq current-newline (position #\newline string :start current-start :end end))      (sws-internal stream string current-start current-newline)      (stream:stream-terpri stream)     ; will force copy to main buffer      (setq current-start (1+ current-newline))      (if (>= current-start end)          (return-from stream:stream-write-string string)))    (if (< current-start end)        (sws-internal stream string current-start end)      string)))  (defun sws-internal (stream string start end)    (let ((current-writer (assoc mp:*current-process* (sios-wbufs stream))))    (unless (cdr current-writer)      (update-alist mp:*current-process* (make-array '(100) :fill-pointer 0 :adjustable t :element-type 'character :initial-element #\space) (sios-wbufs stream))      (setq current-writer (assoc mp:*current-process* (sios-wbufs stream))))    (unless start      (setq start 0))    (unless end      (setq end (length string)))    (let* ((posn (fill-pointer (cdr current-writer)))           (new-fill (- (+ posn end) start))           (temp start)           (needed-increase (- new-fill (array-dimension (cdr current-writer) 0))))      (when (plusp needed-increase)        (adjust-array (cdr current-writer) (list new-fill)                      :element-type 'character))      (while (< posn new-fill)        (setf (elt (cdr current-writer) posn) (elt string temp))        (incf posn)        (incf temp))      (setf (fill-pointer (cdr current-writer)) posn))    string))(defmethod close ((stream string-io-stream-mw) &key abort)  (let ((current-writer (assoc mp:*current-process* (sios-wbufs stream))))    (setf (sios-proc-pointer-alist stream) (delete-if #'(lambda (entry)                                                           (eq (car entry) mp:*current-process*))                                                      (sios-proc-pointer-alist stream)))    (when (cdr current-writer)      (if (and (not abort)               (plusp (fill-pointer (cdr current-writer))))          (stream:stream-terpri stream))      (setf (sios-wbufs stream) (delete-if #'(lambda (entry)                                               (eq (car entry) mp:*current-process*))                                           (sios-wbufs stream))))    (when (null (sios-wbufs stream))      (call-next-method))))               ; everyone we know was writing has closed it.(pushnew :cl-lib-string-io-stream *features*)