(in-package defsys);; Time-stamp: <1999-11-22 17:39:44 brad>;; miller@cs.rochester.edu;; some new modules(eval-when (compile load eval)  (export '(lisp-example-module foreign-syntax-module foreign-syntax-example-module edit-system md-lisp-example-module)));; lisp example - lisp code you don't want to compile but probably want to load.(defclass lisp-example-module (lisp-module) ())  (defmethod compile-module ((module lisp-example-module) &rest keys &key &allow-other-keys)  (declare (ignore keys))  t)                                    ; don't compile it.(defclass foreign-syntax-mixin ()  ((syntax :initform :syntax :accessor foreign-syntax)))(defclass foreign-syntax-module (foreign-syntax-mixin lisp-module) ())(defclass foreign-syntax-example-module (foreign-syntax-mixin lisp-example-module) ())(defmethod load-module ((module foreign-syntax-mixin) &rest keys &key &allow-other-keys)  (declare (ignore keys))  (cl-lib:with-syntax (foreign-syntax module)    (call-next-method)))(defmethod compile-module ((module foreign-syntax-mixin) &rest keys &key &allow-other-keys)  (declare (ignore keys))  (cl-lib:with-syntax (foreign-syntax module)    (call-next-method)))(defmethod intermediate-pathname ((module foreign-module))  (merge-pathnames (make-pathname :type "o")		   (source-pathname module)))(defmethod product-pathname ((module foreign-module))  (merge-pathnames (make-pathname :type #+svr4 "so" #-svr4 "o")		   (source-pathname module)))(defmethod compile-module ((module c-module) &key)  ;; do something like: "cc -c -o foo.o foo.c"  #-svr4  (excl:shell (concatenate 'string			   "cc -c -o "			   (namestring (product-pathname module))			   " "			   (namestring (source-pathname module))))  #+svr4  (excl:shell (concatenate 'string                "cc -K pic -DSVR4 -c -o "                (namestring (intermediate-pathname module))                " "                (namestring (source-pathname module))                "; ld -G -o "                (namestring (product-pathname module))                " "                (namestring (intermediate-pathname module))                )))(defmethod product-pathname ((module lisp-example-module))  (source-pathname module));; edit system(defun edit-system (system &key silent (include-components t))  (let (seen)    (excl:map-system system #'(lambda (module)                                (unless (member module seen) ; because we might see things >1ce.                                  (push module seen)                                  (let ((source (source-pathname module)))                                    (unless silent                                      (format t "Editing source for ~A~%" source))                                    (ed source))))                     :silent t                     :include-components include-components)))(defun release-system (system &key silent (include-components t))  (unless (typep (find-system system) 'md-system)    (return-from release-system :not-md-system))  (let (seen)    (excl:map-system system #'(lambda (module)                                (unless (member module seen) ; because we might see things >1ce.                                  (push module seen)                                  (let ((source (source-pathname module)))                                    (when (pathname-match-p source (format nil "~A*.*" (get-developer-directory module)))                                      (let ((command (format nil "mv ~A ~A" (truename source) (truename (get-master-directory module)))))                                        (unless silent                                          (format t "~A~%" command))                                                                              (excl:shell command))))))                     :silent t                     :include-components include-components)));; system initializations(cl-lib:add-initialization "init random" '(progn (if (fboundp 'tpl:setq-default)                                                     (tpl:setq-default *random-state* (make-random-state t))                                                   (setq *random-state* (make-random-state t)))                                           (format t "Initing *random-state*"))                    '(:warm))#-(and allegro-version>= (version>= 5))(defmethod describe-object ((ht hash-table) stream)  (format stream "~&~S is a Hash-Table. It contains the following elements (key / value):~%")  (maphash #'(lambda (k v)               (format stream ",5t~S~,30t ~S~%" k v))           ht));; directoy from the example in the doc (16-19--16-20). Typed by miller@cs.rochester.edu(defclass md-system (default-system)  ((master-directory :initform nil :initarg :master-directory :accessor master-directory)   (developer-directory :initform nil :initarg :developer-directory :accessor developer-directory)   (syntax :initform nil :initarg :syntax :accessor syntax)))  (defclass md-module-group (default-module-group)  ((master-directory :initform nil :initarg :master-directory :accessor master-directory)   (developer-directory :initform nil :initarg :developer-directory :accessor developer-directory)   (syntax :initform nil :initarg :syntax :accessor syntax)))(defclass md-module (lisp-module)  ((master-directory :initform nil :initarg :master-directory :accessor master-directory)   (developer-directory :initform nil :initarg :developer-directory :accessor developer-directory)   (syntax :initform nil :initarg :syntax :accessor syntax)))(defclass md-c-module (c-module)  ((master-directory :initform nil :initarg :master-directory :accessor master-directory)   (developer-directory :initform nil :initarg :developer-directory :accessor developer-directory)))(defclass md-lisp-example-module (md-module) ())  (defmethod compile-module ((module md-lisp-example-module) &rest keys &key &allow-other-keys)  (declare (ignore keys))  t)                                    ; don't compile it.(defmethod product-pathname ((module md-lisp-example-module))  (source-pathname module))(defmethod get-master-directory ((system md-system))  (master-directory system))(defmethod get-master-directory ((module-group md-module-group))  (or (master-directory module-group)      (get-master-directory (ds:parent-object module-group))))(defmethod get-master-directory ((module md-module))  (or (master-directory module)      (get-master-directory (ds:parent-object module))))(defmethod get-master-directory ((module md-c-module))  (or (master-directory module)      (get-master-directory (ds:parent-object module))))(defmethod get-developer-directory ((system md-system))  (developer-directory system))(defmethod get-developer-directory ((module-group md-module-group))  (or (developer-directory module-group)      (get-developer-directory (ds:parent-object module-group))))(defmethod get-developer-directory ((module md-module))  (or (developer-directory module)      (get-developer-directory (ds:parent-object module))))(defmethod get-developer-directory ((module md-c-module))  (or (developer-directory module)      (get-developer-directory (ds:parent-object module))))(defmethod source-pathname ((module md-module))  ;; if file exists in developer directory then return that,  ;; else return the master directory pathname  (let* ((developer-directory (get-developer-directory module))         (master-directory (get-master-directory module))         (file-name (module-file module))         (default-file-type (default-file-type module))         (file-types sys::*source-file-types*)         (dev-pathname )         (master-pathname ))    (if developer-directory        (if default-file-type            (if (and (setq dev-pathname (merge-pathnames (pathname developer-directory)                                                         (merge-pathnames (pathname file-name)                                                                          (make-pathname  :type default-file-type))))                     (probe-file dev-pathname))                (return-from source-pathname dev-pathname))          (dolist (ftype file-types)            (if (and (setq dev-pathname (merge-pathnames (pathname developer-directory)                                                         (merge-pathnames (pathname file-name)                                                                          (make-pathname :type ftype))))                     (probe-file dev-pathname))                (return-from source-pathname dev-pathname)))))    (if master-directory        (if default-file-type            (if (and (setq master-pathname (merge-pathnames (pathname master-directory)                                                            (merge-pathnames (pathname file-name)                                                                             (make-pathname :type default-file-type))))                     (probe-file master-pathname))                (return-from source-pathname master-pathname))          (dolist (ftype file-types)            (if (and (setq master-pathname (merge-pathnames (pathname master-directory)                                                            (merge-pathnames (pathname file-name)                                                                             (make-pathname :type ftype))))                     (probe-file master-pathname))                (return-from source-pathname master-pathname)))))    (call-next-method)))(defmethod source-pathname ((module md-c-module))  ;; if file exists in developer directory then return that,  ;; else return the master directory pathname  (let* ((developer-directory (get-developer-directory module))         (master-directory (get-master-directory module))         (file-name (module-file module))         (default-file-type (default-file-type module))         (file-types '("c"))         (dev-pathname )         (master-pathname ))    (if developer-directory        (if default-file-type            (if (and (setq dev-pathname (merge-pathnames (pathname developer-directory)                                                         (merge-pathnames (pathname file-name)                                                                          (make-pathname  :type default-file-type))))                     (probe-file dev-pathname))                (return-from source-pathname dev-pathname))          (dolist (ftype file-types)            (if (and (setq dev-pathname (merge-pathnames (pathname developer-directory)                                                         (merge-pathnames (pathname file-name)                                                                          (make-pathname :type ftype))))                     (probe-file dev-pathname))                (return-from source-pathname dev-pathname)))))    (if master-directory        (if default-file-type            (if (and (setq master-pathname (merge-pathnames (pathname master-directory)                                                            (merge-pathnames (pathname file-name)                                                                             (make-pathname :type default-file-type))))                     (probe-file master-pathname))                (return-from source-pathname master-pathname))          (dolist (ftype file-types)            (if (and (setq master-pathname (merge-pathnames (pathname master-directory)                                                            (merge-pathnames (pathname file-name)                                                                             (make-pathname :type ftype))))                     (probe-file master-pathname))                (return-from source-pathname master-pathname)))))    (call-next-method)))(defmethod product-pathname ((module md-module))  ;; always return pathname in developer directory  (let ((developer-directory  (get-developer-directory module)))    (if developer-directory        (merge-pathnames (pathname developer-directory)                         (merge-pathnames (pathname (module-file module))                                          (make-pathname                                           :type (typecase module                                                   (lisp-module                                                    excl:*fasl-default-type*)                                                   (foreign-module                                                    #+svr4                                                    "so"                                                    #-svr4                                                    "o")                                                   (t                                                    nil)))))      (call-next-method))))(defmethod product-pathname ((module md-c-module))  ;; always return pathname in developer directory  (let ((developer-directory  (get-developer-directory module)))    (if developer-directory        (merge-pathnames (pathname developer-directory)                         (merge-pathnames (pathname (module-file module))                                          (make-pathname                                           :type (typecase module                                                   (lisp-module                                                    excl:*fasl-default-type*)                                                   (foreign-module                                                    #+svr4                                                    "so"                                                    #-svr4                                                    "o")                                                   (t                                                    nil)))))      (call-next-method))))  (defmethod intermediate-pathname ((module md-c-module))  ;; always return pathname in developer directory  (let ((developer-directory  (get-developer-directory module)))    (if developer-directory        (merge-pathnames (pathname developer-directory)                         (merge-pathnames (pathname (module-file module))                                          (make-pathname                                           :type (typecase module                                                   (lisp-module                                                    nil)                                                   (foreign-module                                                    "o")                                                   (t                                                    nil)))))      (call-next-method))))(defmethod get-syntax ((module md-module))  (or (syntax module)      (get-syntax (ds:parent-object module))))(defmethod get-syntax ((module md-module-group))  (or (syntax module)      (get-syntax (ds:parent-object module))))  (defmethod get-syntax ((system md-system))  (syntax system))(defmethod compile-module ((module md-module) &rest keys &key &allow-other-keys)  (declare (ignore keys))  (cl-lib:with-syntax (get-syntax module)    (call-next-method)))(defmethod load-module ((module md-module) &rest keys &key &allow-other-keys)  (declare (ignore keys))  (cl-lib:with-syntax (get-syntax module)    (call-next-method)));; This macro binds the class variables to our new classes (defmacro md-defsystem (system-name options &body modules)  `(let ((*default-system-class* 'md-system)         (*default-module-group-class* 'md-module-group)         (*default-module-class* 'md-module))     (excl:defsystem ,system-name ,options ,@modules)))(eval-when (:compile-toplevel :load-toplevel :eval)  (export '(md-defsystem md-c-module) (find-package 'defsys))  (import '(md-defsystem) (find-package 'cl-user))  )(cl-lib:macro-indent-rule md-defsystem (like defsystem));; here is an example of defining a system with our new system options#||(md-defsystem :sys1 (:master-directory #P"master/"                                       :developer-directory #p"devel/"                                       :default-file-type "cl")              (:parallel "filea" "fileb"))||#;; attempt to fix map-system(defvar *mapped-components* nil)(defmethod map-system :around ((system default-system) fun                               &key)  (declare (ignore fun))  (let (*mapped-components*)    (call-next-method)))(defmethod map-module :around ((module default-module) fun &key)  (declare (ignore fun))  (unless (member module *mapped-components*)    (push module *mapped-components*)    (call-next-method)))