(in-package excl);; Time-stamp: <96/01/12 15:57:58 miller>;; miller@cs.rochester.edu 5/19/93 ;; Patch to allegro source (from 4-1). Distributed with permission. See spr8367.(defun sharp-sharp (stream chr label)   (declare (ignore chr))   (when *read-suppress* (return-from sharp-sharp nil))   (if (integerp label)       (let ((ret (gethash label sharp-sharp-alist sharp-sharp-alist))             ret1) 	(if (eq ret sharp-sharp-alist) 	    (internal-reader-error stream "No object labelled #~S=" label)          (if (eq (setq ret1 (gethash ret sharp-equal-alist sharp-equal-alist))                  sharp-equal-alist)              ret            ret1)))     (internal-reader-error stream "Non-integer label #~S#" label))) ;; something we just seem to need in case a non-development image is dumped.;; make it easier to add macros to the lep(eval-when (compile load eval)  (if (member "LEP" *modules* :test #'equal)      (pushnew :lep *features*)))#+sun(defun set-multiply-type (type)   (ecase type     (:hardware (comp::.primcall 'sys::set-multiply-type 1))     (:software (comp::.primcall 'sys::set-multiply-type 0))));;From: Doug Cutting <cutting@parc.xerox.com>;;To: pshell@nl.cs.cmu.edu;;Cc: allegro-cl@ucbvax.berkeley.edu;;Subject: Re: I/O efficiency question;;Date: 	Tue, 23 Feb 1993 13:38:19 PST;;;;;;If you really want to make your program burn, try the following:;(in-package cl-lib);;(defmacro fast-read-char (stream);  #+(and allegro (version>= 4)) `(stream:stream-read-char ,stream);  #+lucid`(lcl:fast-read-char ,stream nil :eof);  #-(or (and allegro (version>= 4)) lucid) `(read-char ,stream nil :eof));;(defmacro fast-read-file-char (stream) `(fast-read-char ,stream));;#+(and allegro (version>= 4));(define-compiler-macro fast-read-file-char (stream);  `(macrolet ((stream-slots (stream);		`(the simple-vector (svref ,stream 1)));	      (stream-buffer (slots);		`(the simple-string (svref ,slots 11)));	      (stream-buffpos (slots);		`(the fixnum (svref ,slots 12)));	      (stream-maxbuffpos (slots);		`(the fixnum (svref ,slots 13))));     (declare (optimize (speed 3) (safety 0)));     (let* ((stream ,stream);	    (slots (stream-slots stream));	    (buffpos (stream-buffpos slots));	    (maxbuffpos (stream-maxbuffpos slots)));       (declare (fixnum buffpos maxbuffpos));       (if (>= buffpos maxbuffpos);	   (stream:stream-read-char stream);	 (prog1 (schar (stream-buffer slots) buffpos);	   (when (= (setf (stream-buffpos slots) (the fixnum (1+ buffpos)));		    maxbuffpos);	     (setf (stream-maxbuffpos slots) 0)))))))