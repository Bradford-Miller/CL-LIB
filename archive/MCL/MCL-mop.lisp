; Some MCL MOP examples; Saturday October 30,1999; Provides a few more CLOS mop capabilities to MCL. This code is highly MCL-specific.; No warranties--use at your own risk. Please send suggestions;   and changes to svspire@nmia.com(defmethod finalize-inheritance ((class standard-class))  (ccl::initialize-class class))#| Don't know if these are meaningful in MCL(defmethod finalize-inheritance ((class funcallable-standard-class))  (ccl::initialize-class class))(defmethod finalize-inheritance ((class forward-referenced-class))  (ccl::initialize-class class))|#; Fails if any class in precedence list is undefined. I think that's what;  AMOP expects to happen.(defmethod compute-class-precedence-list ((class class))  (ccl::compute-cpl class))#| I don't know how to do this in MCL(defmethod class-finalized-p ((class class))  nil)|#(defmethod class-direct-slots ((class class))  (append (class-direct-class-slots class)          (class-direct-instance-slots class)))(defmethod class-slots ((class class))  (append (class-class-slots  class)          (class-instance-slots class)))(defun get-accessors-defined-on (class)  "Returns a list of reader and writer methods for class.   Note that this is just those defined at the level of class, not   all the accessors for all its parent classes."  (ccl::%class-get class 'ccl::accessor-methods))(defun slot-for-accessor (method)  (ccl::method-slot-name method))(defun methods-for-slot (slot-descriptor methods &optional (kind 'STANDARD-READER-METHOD))  "Returns members of methods list which access the given slot as the given    kind of method."  (let* ((slotname (slot-definition-name slot-descriptor))         (mymethods (reverse (remove-if #'(lambda (method)                                           (not (eq slotname                                               (slot-for-accessor method))))                                       methods))))    (remove-if #'(lambda (method)                   (not (typep method kind)))               mymethods)))#|Note that you can't really write the MOP functions #'slot-definition-allocation#'slot-definition-readers, etc. in MCL because slot defs are just lists, and they don'tknow which class they came from.|#; These are pretty inefficient, but they illustrate how to do the job. In a real application, you'd;   probably want to refactor this functionality somewhat for better efficiency.(defmethod mcl-slot-definition-readers ((slot cons) (class standard-class) &optional all-accessors)  (unless all-accessors    (setf all-accessors (get-accessors-defined-on class)))  (mapcar #'method-name (methods-for-slot slot all-accessors 'STANDARD-READER-METHOD)))(defmethod mcl-slot-definition-writers ((slot cons) (class standard-class) &optional all-accessors)  (unless all-accessors    (setf all-accessors (get-accessors-defined-on class)))  (mapcar #'method-name (methods-for-slot slot all-accessors 'STANDARD-WRITER-METHOD)))(defmethod mcl-slot-definition-accessors ((slot cons) (class standard-class) &optional all-accessors)  (unless all-accessors    (setf all-accessors (get-accessors-defined-on class)))  (intersection   (mcl-slot-definition-readers slot class all-accessors)   (mcl-slot-definition-writers slot class all-accessors)   :key #'(lambda (thing) (if (atom thing) thing (second thing))) ; account for SETF methods   ))    #| These are already defined in MCL 3 and above:slot-definition-initformslot-definition-initfunctionslot-definition-initargsslot-definition-typeslot-definition-name|##| ; TESTS(defclass foo ()  ((slot1 :initarg :slot1 :initform 'hello :type 'fixnum :accessor slot1)   (slot2 :initarg :slot2 :initform 5 :accessor slot2)   (slot3 :initarg :slot3 :initform nil :accessor slot3 :reader another-slot3-reader :allocation :class)))(get-accessors-defined-on (find-class 'foo))--> (#<STANDARD-READER-METHOD SLOT1 (FOO)>     #<STANDARD-WRITER-METHOD (SETF SLOT1) (T FOO)>     #<STANDARD-READER-METHOD SLOT2 (FOO)>     #<STANDARD-WRITER-METHOD (SETF SLOT2) (T FOO)>     #<STANDARD-READER-METHOD SLOT3 (FOO)>     #<STANDARD-WRITER-METHOD (SETF SLOT3) (T FOO)>     #<STANDARD-READER-METHOD ANOTHER-SLOT3-READER (FOO)>)(mapcar #'ccl::slot-definition-type (class-slots (find-class 'foo)))--> (T 'FIXNUM T)(mapcar #'ccl::slot-definition-initargs (class-slots (find-class 'foo)))--> ((:SLOT3) (:SLOT1) (:SLOT2))(mapcar #'ccl::slot-definition-initform (class-slots (find-class 'foo)))--> (NIL HELLO 5)(mapcar #'ccl::slot-definition-initfunction (class-slots (find-class 'foo)))--> (#²COMPILED-LEXICAL-CLOSURE #xA83D356³ #²COMPILED-LEXICAL-CLOSURE #xA83D376³ #²COMPILED-LEXICAL-CLOSURE #xA83D396³)(mcl-slot-definition-readers (first (class-slots #1=(find-class 'foo))) #1#)--> (ANOTHER-SLOT3-READER SLOT3)(mcl-slot-definition-writers (first (class-slots #1=(find-class 'foo))) #1#)--> ((SETF SLOT3))(mcl-slot-definition-accessors (first (class-slots #1=(find-class 'foo))) #1#)--> (SLOT3)|#;;; still undefined!! [BWM];; class-default-initargs;; class-direct-default-initargs;; generic-function-argument-precedence-order;; generic-function-declarations;; generic-function-initial-methods;; generic-function-lambda-list;; method-lambda-list;; slot-boundp-using-class;; slot-definition-class;; slot-definition-allocation;; slot-exists-p-using-class;; slot-makunbound-using-class;; slot-value-using-class