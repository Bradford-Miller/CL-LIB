(in-package CL-LIB)(cl-lib:version-reporter "CL-LIB-Reader" 5 16 ";; Time-stamp: <2019-05-19 17:18:52 Bradford Miller(on Aragorn.local)>"                          "toplevel forms");; 5.16. 2/23/19  fix toplevel forms;;;;;;; (C) 1993 by Bradford W. Miller and the Trustees of the University of Rochester.;;;; (C) 2019 by Bradford W. Miller;; This library is free software; you can redistribute it and/or modify it under the terms of the GNU ;; Lesser General Public License as published by the Free Software Foundation; either version 3.0 of ;; the License, or (at your option) any later version.;; This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; ;; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. ;; See the GNU Lesser General Public License for more details.;; You should have received a copy of the GNU Lesser General Public License along with this library; ;; if not, see <http://www.gnu.org/licenses/>.;; miller - Brad Miller (bradfordmiller@mac.com);;; This is the incremental file expression reader package written by ;;;   Bradford W. Miller;;;   University of Rochester, Department of Computer Science;;;   610 CS Building, Comp Sci Dept., U. Rochester, Rochester NY 14627-0226;;;   716-275-1118;;; I will be glad to respond to bug reports or feature requests.;;;;;; This version was NOT obtained from the directory;;; /afs/cs.cmu.edu/user/mkant/Public/Lisp-Utilities/reader.lisp;;; via anonymous ftp from a.gp.cs.cmu.edu. (you got it in cl-lib).;;;;;; Note: The use of (raw-read-char) can translate to (read-char) on most;;; architectures, under Allegro, it puts Gnu Emacs into raw mode, so a single;;; character will be transmitted instead of waiting for an entire (buffered) line.;;; (when using the fi interface, and loading more-allegro.lisp in the cl-lib ;;; distribution).#-allegro(defun raw-read-char ()  ;; under emacs, we need to get the line anyway.  (let ((result (read-line)))    (if (eql (length result) 0)        #\return        (elt result 0))))(defun do-non-clim-reader (pointer reader-expr obj)  (flet ((eval-expr (expr)           (restart-case                (PRINT (MULTIPLE-VALUE-LIST (eval eXPR)))             (nil ()                 :report                   (lambda (s) (format s "Continue READER as if form is ok"))))))    (loop       (format t "~%~%~a. ~s" pointer reader-expr)       (let ((input-char (raw-read-char)))         (case input-char           ((#\space #\y #+lispm #\end #\return #-symbolics #\newline)            (eval-expr reader-expr)            (return-from do-non-clim-reader nil))           (#\q            (throw :abort 'end))           (#\s            (let ((skip (read)))              (while (plusp (decf skip))                (if (eq (read obj nil 'end) 'end)                    (return-from do-non-clim-reader 'end))                (incf pointer))              (return-from do-non-clim-reader nil)))           (#\e            (format t "val: ")            (eval-expr (read))            (terpri))           (#\(            (unread-char input-char)            (format t "val: ")            (eval-expr (read))            (terpri))           ((#\1 #\2 #\3 #\4 #\5 #\6 #\7 #\8 #\9)            (eval-expr reader-expr)            (unread-char input-char)            (dotimes (count (- (parse-integer (read))                               1))              (progn count)              (if (eq (setq reader-expr (read obj nil 'end)) 'end)                  (return-from do-non-clim-reader 'end))              (eval-expr reader-expr)              (incf pointer))            (return-from do-non-clim-reader nil))           (t (format t "~%~%summary of commands~~~~~~~~~~~~~~~~~~~<space>, y, <end>: evaluates the next expression.<number> : evaluates the next <number> of expressions.s <number> : skips the next <number> of expressions.e <lisp-expr> : evaluates the <lisp-expr>.q : to exit the READER.? : prints out this menu.")              ))))))#+clim(defun do-clim-reader (pointer reader-expr)  (flet ((eval-expr (expr)           (format t "~%~%~a. ~s" pointer expr)           (restart-case                (PRINT (MULTIPLE-VALUE-LIST (eval eXPR)))             (nil ()                 :report                   (lambda (s) (format s "Continue READER as if form is ok"))))))    (let ((stream *query-io*))      (restart-case          (progn            (CLIM:accepting-values (stream :own-window t                                            :exit-boxes '((:exit "<return> evaluate this term" )                                                          (:abort "aborts")))              (format stream "~D: " pointer)              (clim:present reader-expr 'clim:form :stream stream)              (terpri stream)              (progfoo (CLIM:accept 'clim:form :stream stream :prompt "Evaluate an expression")                (when foo                  (eval-expr foo))))            ;; If we get here Ok was selected            (eval-expr reader-expr))        ;; If we get here Abort was selected        (abort () (throw :abort :abort))))))(defun reader (filename)  (catch :abort    (let ((reader-expr nil)          (pointer 0))      (with-open-file (obj filename)        (loop          (while (member (setq reader-expr (peek-char nil obj nil 'end))                         '(#\space #\return #\newline #\;))            (if (eql reader-expr #\;)                (write-line (read-line obj nil #\space))              (write-char (read-char obj))))          (if (eq reader-expr 'end)              (return-from reader 'end))          (if (eq (setq reader-expr (read obj nil 'end)) 'end)              (return-from reader 'end))          (incf pointer)          #-clim (do-non-clim-reader pointer reader-expr obj)          #+clim (do-clim-reader pointer reader-expr)))      :reader-done)))(eval-when (:load-toplevel :execute)  (export '(reader)))(pushnew :cl-lib-reader *features*)