(in-package cl-user)(cl-lib:version-reporter "CL-LIB-Transcripts" 5 13 ";; Time-stamp: <2011-11-16 17:31:23 millerb>"                          "CVS: $Id: transcripts.lisp,v 1.5 2011/11/24 16:05:50 millerb Exp $;; *suppress-logs*");; 5.13 11/16/11 add *suppress-logs* to disable opening logs (e.g. when testing from console);; 5.12 11/10/11 open-transcript-stream-p open-log-stream-p;; 5.10  5/ 2/08;; 5.7  11/22/07 function documentation;; 5.5  10/15/07 efficiency of apply-format (also bug workaround);; 5.3   5/18/07 open-interactive-log-stream;; Additional changes Copyright (C) 2011 Bradford W. Miller. Released under license as below.;; THE TRANSCRIPTS PACKAGE: Bradford W. Miller;;   made part of CL-LIB  12/19/99 by gorbag@jump.net (BW Miller);; Based on code written for the TDS poject by Bradford W. Miller (miller@cs.rochester.edu) 6/1994.;;  Reused for TRAINS 9/1995.;;;; This portion of CL-LIB Copyright (C) 1994-2008 Bradford W. Miller and the Trustees of the University of Rochester;; ;; This library is free software; you can redistribute it and/or modify it under the terms of the GNU ;; Lesser General Public License as published by the Free Software Foundation; either version 3.0 of ;; the License, or (at your option) any later version.;; This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; ;; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. ;; See the GNU Lesser General Public License for more details.;; You should have received a copy of the GNU Lesser General Public License along with this library; ;; if not, see <http://www.gnu.org/licenses/>.(defpackage :transcripts  (:use common-lisp cl-lib)  (:export   #:do-log #:do-log-timestamp #:transcribe #:transcribe-and-log #:open-transcript-stream #:open-log-stream #:close-logs   #:open-log-stream-for-module ;; added 9/28 - use in trains   #:find-log-stream #:log-warning #:open-interactive-log-stream   #:debug-p #:debug-log #:when-debugging   #:stamp-view-log-indicator #:do-log-all   #:*transcript-stream* #:*log-file* #:*log-streams* #:*crash-log-stream*   #:open-transcript-stream-p #:open-log-stream-p   #:tassert   #:write-log-header   #:*suppress-transcripts* #:*suppress-logs*)  (:documentation "This package defines a mechanism for creating transcript, log, and debug type files in a somewhat structuredmanner."))(in-package :transcripts)(defvar *suppress-transcripts* nil "When non-nil, supress all (non-crash) logging activities")(defvar *suppress-logs* nil "When non-nil, supress opening logs");; patch#+excl(excl:without-package-locks (defmethod open-stream-p ((x null))   nil))(defun check-for-lep ()  "running under emacs?"  #+excl  (and (find-package 'lep)       (funcall (intern "LEP-IS-RUNNING" (find-package 'lep))))  #-excl  nil)(defvar *log-file* nil "Path to a log file")(defvar *transcript-stream* nil        ; global  "Stream for the transcript")(defvar *transcript-stream-stamp* '(1 2 3) "when we last printed to stream, so we know if we should drop a timestamp")(defvar *log-streams* nil              ; global  "Streams open for logs")(defvar *crash-log-stream* nil "Special stream for dealing with crash messages")(defgeneric write-log-header (stream who)  (:documentation "Puts a header at the top of each log file. For a particular who, may be overridden by the caller bydefining a method."))(defmethod write-log-header (stream (who t))  (mlet (second minute hour date month year) (get-decoded-time)    (format stream "~&\;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;                                                    ;;;;;;;;       Logfile for ~A~56T;;;;;;;;                                                    ;;;;;;;;       Opened: ~D/~D/~4D ~2,'0D:~2,'0D:~2,'0D~56T;;;;;;;;                                                    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;~%~%"            who month date year hour minute second)))(defun drop-timestamp (stream last-timestamp &optional who)  (mlet (second minute hour) (get-decoded-time)    (let ((stamp (list second minute hour)))      (unless (and (not (null last-timestamp))                   (equalp stamp (symbol-value last-timestamp)))        (if who            (format stream "~&<~2,'0D:~2,'0D:~2,'0D>(~A)~%" hour minute second who)          (format stream "~&<~2,'0D:~2,'0D:~2,'0D>~%" hour minute second))        (set last-timestamp stamp)))))(defun apply-format (stream control arguments)  (declare (special cl-user::*debug*))  (if arguments    (apply #'format stream control arguments)    (write-string control stream)) ;; faster  (fresh-line stream)  (if cl-user::*debug*      (force-output stream)))(defun open-log-stream-p (log-stream)  (and (not (null log-stream))       (streamp log-stream)       (open-stream-p log-stream)))(defun open-transcript-stream-p ()  (open-log-stream-p *transcript-stream*))(defun transcribe (who control &rest arguments)  "drop a timestamped message into the transcript from WHO."  (declare (ignore who))  (unless *suppress-transcripts*    (when (open-transcript-stream-p)      (drop-timestamp *transcript-stream* '*transcript-stream-stamp*)      (apply-format *transcript-stream* control arguments))))(defun transcribe-and-log (who control &rest arguments)  "Like transcribe, but also drops into who's log."  (apply #'transcribe who control arguments)  (apply #'do-log who control arguments))(defun find-log-stream (who)  "Given a who parameter, returns the associated log stream from *log-streams*"  (values-list (cdr (assoc (make-keyword who) *log-streams*))))(defun update-stamp (who stamp)  (setf (second (cdr (assoc (make-keyword who) *log-streams*))) stamp))(defun do-log (who control &rest arguments)  "writes to the who logfile based on format control/arguments."  (unless *suppress-transcripts*    (let ((*print-circle* t)          (*print-length* 400)          (*print-level* 20)          (*print-pretty* t)          (*print-readably* nil))      (apply #'do-log-direct who control arguments))))(defvar *log-timestamp* nil)(defun do-log-direct (who control &rest arguments)  (mlet (log-stream *log-timestamp*) (find-log-stream who)    (unless (open-log-stream-p log-stream)      (when *log-file*        (open-log-stream-for-module who)        (setq log-stream (find-log-stream who))))    (cond     ((open-log-stream-p log-stream)      (drop-timestamp log-stream '*log-timestamp*)      (update-stamp who *log-timestamp*)      (apply-format log-stream control arguments)))));; useful for metering(defun do-log-timestamp (who control &rest arguments)  "Like do-log, but adds a timestamp"  (unless *suppress-transcripts*    (let ((*print-circle* t)          (*print-length* 400)          (*print-level* 20)          (*print-pretty* t)          (*print-readably* nil))      (apply #'do-log-direct-timestamp who control arguments))))(let ((run-time 0)      (real-time 0))  (defun reset-timestamp ()    (setq run-time (get-internal-run-time)          real-time (get-internal-real-time)))    (defun do-log-direct-timestamp (who control &rest arguments)    (mlet (log-stream stamp) (find-log-stream who)      (declare (ignore stamp))      (unless (open-log-stream-p log-stream)        (when *log-file*          (open-log-stream-for-module who)          (setq log-stream (find-log-stream who))))      (let ((current-run-time (- (get-internal-run-time) run-time))            (current-real-time (- (get-internal-real-time) real-time)))        (cond         ((open-log-stream-p log-stream)          (format log-stream "~&< ~9D Run: ~9D Real>(~A) " current-run-time current-real-time who)          (apply-format log-stream control arguments)))))))(defun debug-p (debug-level-needed)  "Return non-nil, if cl-user::*debug* is high enough to trigger debugging"  (declare (special cl-user::*debug* cl-user::*debug-levels*))    (when cl-user::*debug*                   ; skip if debugging is off    (or (eql cl-user::*debug* t)        (let ((posn-debug (position cl-user::*debug* cl-user::*debug-levels*))              (posn-needed (position debug-level-needed cl-user::*debug-levels*)))          (and (integerp posn-debug)               (integerp posn-needed)               (<= posn-needed posn-debug))))))(defmacro when-debugging (debug-level-needed &body body)  "Macro that wraps the body in a (when (debug-p ,debug-level-needed) ,@body)"  `(when (debug-p ,debug-level-needed)     ,@body))(defun debug-log (who debug-level control &rest arguments)  "Main function for writing a messge to a debug log file. Users cl-user::*debug* and compares to debug-level to determine if thediagnostic should be written. who defines which log file to use, control and arguments are as for format."  (declare (special cl-user::*debug*))  (cond   ((or *suppress-transcripts*        (null cl-user::*debug*)))           ; not debugging, so just return   ((consp who)    ;; multiple logs    (mapc #'(lambda (x) (apply #'debug-log x debug-level control arguments))          (delete-duplicates who :key #'find-log-stream))) ; only if they have different log streams         ((or (debug-p debug-level)        (debug-p (make-keyword who)))    (apply #'do-log who control arguments))))(defun log-warning (who control &rest arguments)  "Special warning formatting, and also sends to :warnings transcript"  (cond   ((consp who)    ;; multiple logs    (mapc #'(lambda (x) (apply #'do-log x control arguments))          (delete-duplicates who :key #'find-log-stream))    (apply #'do-log :warnings control arguments))   (t    (apply #'do-log who control arguments)    (apply #'do-log :warnings control arguments))))(defun close-logs ()  "Close all open logs, after writing a timestamp to them."  (mlet (second minute hour) (get-decoded-time)    (when (open-transcript-stream-p)      (format *transcript-stream* "~&~%~%;; **** Log Closed: <~2,'0D:~2,'0D:~2,'0D> ****~%" hour minute second)      (close *transcript-stream*))    (dolist (ls *log-streams*)      (when (and (open-log-stream-p (cadr ls)) (not (equalp (cadr ls) *error-output*)))        (format (cadr ls) "~&~%~%;; **** Log Closed: <~2,'0D:~2,'0D:~2,'0D> ****~%" hour minute second)        (close (cadr ls))))    (setq *log-streams* nil)))(defun open-transcript-stream (file)  "Opens a distinguished *transcript-stream* using file, after closing *transcript-stream* if it's an open stream."  (when (open-transcript-stream-p)    (close *transcript-stream*))  (when (and file (not *suppress-logs*))    (setq *transcript-stream* (open file                                    :direction :output                                    :if-exists :append                                    :if-does-not-exist :create))    (format *transcript-stream* ";; Transcript stream ~(~A~)~%~%" file)))(defun open-log-stream-for-module (who &optional interactive-p)  "Opens a log stream for the passed module."  (unless *suppress-logs*    (assert (and (symbolp who) (not (null who))) (who) "Who should be a non-null symbol")    (setq who (make-keyword who))    (let ((log-stream (find-log-stream who)))      (unless (open-log-stream-p log-stream)        (let ((new-stream               (cond                (interactive-p                 ;; use *error-output*  -  useful for having some version of logging when running from a listener.                 *error-output*)                (t                 (open (merge-pathnames (pathname (string-downcase (string who) :start 1)) (pathname *log-file*))                       :direction :output                       :if-exists :append                       :if-does-not-exist :create)))))          (write-log-header new-stream who)          (update-alist who (list new-stream '())                        *log-streams*))))))(defun open-log-stream (file default-module)  "Closes all the logs, then uses the passed file name as the default log stream for the module and sets it up as the *crash-log-stream*"  (if *log-streams* (close-logs))  (unless *suppress-logs*    (setq *log-file* file)    (when file      (open-log-stream-for-module (make-keyword default-module))      (setq *crash-log-stream* (find-log-stream (make-keyword default-module))))))(defun open-interactive-log-stream (default-module)  "Closes all the logs, then uses standard out as the default log stream for the module and sets it up as the *crash-log-stream*"  (if *log-streams* (close-logs))  (open-log-stream-for-module (make-keyword default-module) t)  (setq *crash-log-stream* (find-log-stream (make-keyword default-module))))(defun do-log-all (control &rest arguments)  "Write the log entry to all *log-streams*"  (apply #'transcribe nil control arguments)  (dolist (entry *log-streams*)    (apply #'do-log (car entry) control arguments)))(defun stamp-view-log-indicator (number message &optional info-only)  "Print a message to all logs. If info-only is nil, scare formatting is used."  (if info-only      (do-log-all "~&;;; *** ~D ~W~%" number message)    (do-log-all "~&;;; ***~%;;; ***~%;;; ***VL*** ~D ~W~%;;; ***~%;;; ***" number message)))(defmacro tassert (who debug-level test-form &optional places string &rest args)  "TASSERT who debug-level test-form [({place}*) [string {arg}*]]   If the test-form evals to NIL, then either signal an error or log an error, depending on the value of debug-level: if current tracing is such that we would   normally trace debug-level, assert instead. If tracing is such that we would ignore, log instead."    `(cond    ((debug-p ,debug-level)     ;; we do it this way instead of checking test-form to avoid reevaluation of test-form and make sure we use the host CL's version of assert.     (assert ,test-form ,places ,string ,@args))    (,test-form     nil)    (t     (do-log ,who ,string ,@args))))(pushnew :cl-lib-transcripts *features*)