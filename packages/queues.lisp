;;; -*- Mode: LISP; Syntax: Ansi-common-lisp; Package: CL-LIB; Base: 10 -*-(in-package CL-LIB)(cl-lib:version-reporter "CL-LIB-Queues" 5 0 ";; Time-stamp: <2012-01-05 17:47:01 millerb>"                          "CVS: $Id: queues.lisp,v 1.2 2012/01/05 22:47:56 millerb Exp $restructured version");;; This is a copy of the implementation for queues from Waters and;;; Norvig's "Implementating Queues in Lisp" reprinted in TR 91-04;;; Mitsubishi Electric Research Laboratories. "Some Useful Lisp;;; Algorithms: Part 1";; Waters and Norvig present 3 final implementations, two based on;; lists, and one on vectors.  The trade-off is (in space time for the;; following operations);;                           Figure 16     Figure 17    Figure 19;; operation                    s  t         s   t        s   t;;;; empty-queue-p                2  2         3   3        3   3;;;; queue-front                  2  2         3   3        3   3;;;; dequeue                      7  6         4   4        5   5;;;; enqueue                      4  4         4   4        8   7;;;; Because we feel for most of our own code the enqueues and dequeues;; are roughly balanced, but are more important than checking the;; front or for an empty queue, the following code is from figure;; 17. While not all compilers will support the inline declaration, we;; have so declared it "just in case".(declaim (inline make-queue queue-elements empty-queue-p                 queue-front dequeue enqueue))(defun make-queue ()  "Creates and returns a new empty queue"  (let ((q (list nil)))    (cons q q)))(defun queue-elements (q)  "Returns a list of the elements in queue with the oldest element first.The list returned may share structure with queue and therefore may be alteredby subsequent calls on enqueue and/or dequeue"  (cdar q))(defun empty-queue-p (q)  "Returns t if queue does not contain any elements and nil otherwise"  (null (cdar q)))(defun queue-front (q)  "Returns the oldest element in queue (i.e., the element that hasbeen in the queue the longest). When queue is empty, the results areundefined"  (cadar q))(defun dequeue (q)  "Queue is altered (by side effect) by removing the oldest element inqueue. THe removed element is returned. When queue is empty, theresults are undefined."  (car (setf (car q) (cdar q))));; this function contributed by bradford.w.miller@gmail.com(defun safe-dequeue (q)  "Dequeue that makes sure there is a non-empty queue, returning NILif queue is empty. (dequeue on empty queue will screw the datastructure!)"  (unless (empty-queue-p q)    (dequeue q)))(defun enqueue (q item)  "Queue is altered (by side-effect) by adding the element item intoqueue. The return value (if any) is undefined."  (setf (cdr q)        (setf (cddr q) (list item))))#||(setq q (make-queue)) -> (#1=(nil) . #1)(progn (enqueue q 'a) (enqueue q 'b) (enqueue q 'c) q) -> ((nil a b . #1=(c)) . #1#)||#(pushnew :cl-lib-queues *features*)