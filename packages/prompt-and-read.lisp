;;; -*- Mode: LISP; Syntax: ansi-common-lisp; Package: CL-LIB; Base: 10 -*-(in-package cl-lib)(cl-lib:version-reporter "CL-LIB-Prompt" 5 0 ";; Time-stamp: <2007-05-18 11:27:37 miller>"                          "CVS: $Id: prompt-and-read.lisp,v 1.1.1.1 2007/11/19 17:46:48 gorbag Exp $restructured version");;; ;;; Copyright (C) 1994 by Bradford W. Miller, miller@cs.rochester.edu;;;                       and the Trustees of the University of Rochester;;; Right of use & redistribution is granted as per the terms of the ;;; GNU LIBRARY GENERAL PUBLIC LICENCE version 2 which is incorporated here by;;; reference. ;;; This program is free software; you can redistribute it and/or modify;;; it under the terms of the GNU Library General Public License as published by;;; the Free Software Foundation; version 2.;;; This program is distributed in the hope that it will be useful,;;; but WITHOUT ANY WARRANTY; without even the implied warranty of;;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the;;; GNU Library General Public License for more details.;;; You should have received a copy of the GNU Library General Public License;;; along with this program; if not, write to the Free Software;;; Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.;;;;;; The following is contributed by miller@cs.rochester.edu;;; various incantations for prompting for a non-binary choice (see also query.lisp in this directory).;;; if CLIM is active, use that... thanks to George Ferguson for the initial take on the following three ;;; functions... (ferguson@cs.rochester.edu)#+clim(defun popup-read-form (type &optional (prompt nil pp) (default nil dp))  "Pops up a dialog box to read a symbol. Returns two values: the symbolor NIL if Aborted and a flag that is T if Aborted."  (let (x        (stream *query-io*))    (restart-case	(progn	  (CLIM:accepting-values (stream :own-window t)            (setq x              (cond ((and pp dp)                     (CLIM:accept type :stream stream :prompt prompt :default default))                    (pp                     (CLIM:accept type :stream stream :prompt prompt))                    (dp                     (CLIM:accept type :stream stream :default default))                    (t                     (CLIM:accept type :stream stream)))))	  ;; If we get here Ok was selected	  (values x nil))      ;; If we get here Abort was selected      (abort () (values nil t)))))(defvar *suppress-clim* nil "Turn off clim i/o")(defun prompt-and-read (prompt &rest prompt-args)  "Prompt the user for an arbitrary response."  #+clim  (unless *suppress-clim*    (return-from prompt-and-read      (clim-prompt-for '(clim::form :auto-activate t) prompt prompt-args)))  (apply #'format *query-io* prompt prompt-args)  (read *query-io*))(defun prompt-for (type &optional prompt &rest prompt-args)  "inspired by cltl/2, condition chapter."  (unless prompt    (setq prompt (format nil "Please enter a ~A" type)))  #+clim  (unless *suppress-clim*    (return-from prompt-for      (clim-prompt-for type prompt prompt-args)))  (let (result)    (while-not (typep (setq result (apply #'prompt-and-read prompt prompt-args)) type))    result))#+clim(defun clim-prompt-for (type prompt prompt-args)  (loop    (mlet (result aborted)        (popup-read-form (convert-to-presentation-type type) (if prompt (apply #'format nil prompt prompt-args)))      (cond       (aborted        (if (find-restart 'abort)            (abort)          (return-from clim-prompt-for (values nil t))))       (t        (return-from clim-prompt-for result))))))#+clim(defun clim-prompt-for-with-default (type default prompt prompt-args)  (loop    (mlet (result aborted)        (popup-read-form (convert-to-presentation-type type) (if prompt (apply #'format nil prompt prompt-args)) default)      (cond       (aborted        (if (find-restart 'abort)            (abort)          (return-from clim-prompt-for-with-default (values nil t))))       (t        (return-from clim-prompt-for-with-default result))))))#+clim (defvar *default-presentation-type* '((clim:form) :auto-activate t))#+clim(defgeneric convert-to-presentation-type (type)  (:documentation "Convert a lisp type into a presentation type."))#+clim(defgeneric convert-satisfies-to-presentation-type (predicate args)  (:documentation "Convert a satisfies predicate into a presentation type."))#+clim(defmethod convert-to-presentation-type ((type t))  (if (clim:presentation-type-specifier-p type)      type    *default-presentation-type*))#+clim(defmethod convert-to-presentation-type ((type list))  ;; handle satisfies, if user has defined it.  (if (equal (car type) 'satisfies)      (convert-satisfies-to-presentation-type (cadr type) (cddr type))    (call-next-method)))(pushnew :cl-lib-prompt-and-read *features*)