;;; -*- Mode: LISP; Syntax: Ansi-common-lisp; Package: CL-LIB; Base: 10 -*-(IN-PACKAGE CL-LIB)(version-reporter "CL-LIB-FNS-Strings" 5 0 ";; Time-stamp: <2008-05-03 13:36:04 gorbag>"                   "CVS: $Id: strings.lisp,v 1.2 2008/05/03 17:42:01 gorbag Exp $restructured version");; This portion of CL-LIB Copyright (C) 1986-2008 Bradford W. Miller and the;;                                                Trustees of the University of Rochester;; ;; This library is free software; you can redistribute it and/or modify it under the terms of the GNU ;; Lesser General Public License as published by the Free Software Foundation; either version 3.0 of ;; the License, or (at your option) any later version.;; This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; ;; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. ;; See the GNU Lesser General Public License for more details.;; You should have received a copy of the GNU Lesser General Public License along with this library; ;; if not, see <http://www.gnu.org/licenses/>.;;;; Note the local extensions remain in cl-extensions. <miller>;;;;; ****************************************************************;;;; Extensions to Common Lisp **************************************;;;; ****************************************************************;;;;;;;; This file is a collection of extensions to Common Lisp. ;;;;;;;; It is a combination of the CL-LIB package copyleft by Brad Miller;;;; <miller@cs.rochester.edu> and a similar collection by;;;; Mark Kantrowitz <mkant+@cs.cmu.edu>.;;;;;;;; The following functions were originally from CL-LIB:;;;;   let-if, factorial, update-alist, truncate-keywords, while,;;;;   defclass-x, copy-hash-table, defflag, round-to, extract-keyword;;;;   let*-non-null, mapc-dotted-list, ;;;;   mapcar-dotted-list, mapcan-dotted-list, some-dotted-list, ;;;;   every-dotted-list, msetq, mlet, dosequence, force-string, prefix?,;;;;   elapsed-time-in-seconds, bit-length, flatten, ;;;;   sum-of-powers-of-two-representation, ;;;;   difference-of-powers-of-two-representation,;;;;   ordinal-string, between, ;;;;   cond-binding-predicate-to <quiroz@cs.rochester.edu>;;;;   remove-keywords <baldwin@cs.rochester.edu>;;;;;;;; The following functions were contributed by Mark Kantrowitz:;;;;   circular-list, dofile, seq-butlast, seq-last, firstn, in-order-union;;;;   parse-with-delimiter, parse-with-delimiters, string-search-car,;;;   string-search-cdr, parallel-substitute, lisp::nth-value,;;;;   parse-with-string-delimiter, parse-with-string-delimiter*,;;;;   member-or-eq, number-to-string, null-string, time-string.;;;;   list-without-nulls, cartesian-product, cross-product, permutations;;;;   powerset, occurs, split-string, format-justified-string, ;;;;   eqmemb, neq, car-eq, dremove, displace, tailpush, explode,;;;;   implode, crush, listify-string, and-list, or-list, lookup,;;;;   make-variable, variablep, make-plist, make-keyword;;;;   ;;;; The GNU Emacs distribution agreement is included by reference.;;;; Share and Enjoy!;;;;;;;; Uncomment this to make the extensions accessible from the Lisp package;;; without the EXT prefix.;(in-package "LISP");;; ********************************;;; Strings ************************;;; ********************************(defun string-search-car (character-bag string)  "Returns the part of the string before the first of the delimiters in    CHARACTER-BAG and the delimiter."  (let* ((delimiter nil)	 (delimiter-position (position-if #'(lambda (character)					      (when (find character 							  character-bag)						(setq delimiter character)))					  string)))    (values (subseq string 0 delimiter-position)	    delimiter)))(defun string-search-cdr (character-bag string)  "Returns the part of the string after the first of the delimiters in    CHARACTER-BAG, if any, and the delimiter. If none of the delimiters    are found, returns NIL and NIL."  (let* ((delimiter nil)	 (delimiter-position (position-if #'(lambda (character)					      (when (find character 							  character-bag)						(setq delimiter character)))					 string)))    (if delimiter-position	(values (subseq string (1+ delimiter-position))		delimiter)	;; Maybe this should be "" instead of NIL?	(values nil delimiter))))(defun parse-with-delimiter (line &optional (delim #\newline))  "Breaks LINE into a list of strings, using DELIM as a    breaking point."  ;; what about #\return instead of #\newline?  (let ((pos (position delim line)))    (cond (pos           (cons (subseq line 0 pos)                 (parse-with-delimiter (subseq line (1+ pos)) delim)))          (t           (list line)))))(defun parse-with-delimiters (line &optional (delimiters '(#\newline)))  "Breaks LINE into a list of strings, using DELIMITERS as a    breaking point."  ;; what about #\return instead of #\newline?  (let ((pos (position-if #'(lambda (character) (find character delimiters))			    line)))    (cond (pos           (cons (subseq line 0 pos)                 (parse-with-delimiters (subseq line (1+ pos)) delimiters)))          (t           (list line)))));;; subst:sublis::substitute:?  -- cl needs a parallel-substitute for;;; performing many substitutions in a sequence in parallel.(defun parallel-substitute (alist string)  "Makes substitutions for characters in STRING according to the ALIST.    In effect, PARALLEL-SUBSTITUTE can perform several SUBSTITUTE   operations simultaneously."  (declare (simple-string string))  ;; This function should be generalized to arbitrary sequences and  ;; have an arglist (alist sequence &key from-end (test #'eql) test-not  ;; (start 0) (count most-positive-fixnum) end key).  (if alist      (let* ((length (length string))	     (result (make-string length)))	(declare (simple-string result))	(dotimes (i length)	  (let ((old-char (schar string i)))	    (setf (schar result i)		  (or (second (assoc old-char alist :test #'char=))		      old-char))))	result)      string))(defun parse-with-string-delimiter (delim string &key (start 0) end)  "Returns up to three values: the string up to the delimiter DELIM   in STRING (or NIL if the field is empty), the position of the beginning   of the rest of the string after the delimiter, and a value which, if   non-NIL (:delim-not-found), specifies that the delimiter was not found."  (declare (simple-string string))  ;; Conceivably, if DELIM is a string consisting of a single character,  ;; we could do this more efficiently using POSITION instead of SEARCH.  ;; However, any good implementation of SEARCH should optimize for that  ;; case, so nothing to worry about.  (setq end (or end (length string)))  (let ((delim-pos (search delim string :start2 start :end2 end))	(dlength (length delim)))    (cond ((null delim-pos)			   ;; No delimiter was found. Return the rest of the string,	   ;; the end of the string, and :delim-not-found.	   (values (subseq string start end) end :delim-not-found))	  ((= delim-pos start)			   ;; The field was empty, so return nil and skip over the delimiter.	   (values nil (+ start dlength)))	  ;; The following clause is subsumed by the last cond clause,	  ;; and hence should probably be eliminated.	  (t					   ;; The delimiter is in the middle of the string. Return the	   ;; field and skip over the delimiter. 	   (values (subseq string start delim-pos)		   (+ delim-pos dlength))))))(defun parse-with-string-delimiter* (delim string &key (start 0) end					   include-last)  "Breaks STRING into a list of strings, each of which was separated   from the previous by DELIM. If INCLUDE-LAST is nil (the default),   will not include the last string if it wasn't followed by DELIM   (i.e., \"foo,bar,\" vs \"foo,bar\"). Otherwise includes it even if   not terminated by DELIM. Also returns the final position in the string."  (declare (simple-string string))  (setq end (or end (length string)))  (let (result)    (loop     (if (< start end)	 (multiple-value-bind (component new-start delim-not-found)	     (parse-with-string-delimiter delim string :start start :end end)	   (when delim-not-found 	     (when include-last	       (setq start new-start)	       (push component result))	     (return))	   (setq start new-start)	   (push component result))	 (return)))    (values (nreverse result) 	    start)));; set in user-manual(defun split-string (string &key (item #\space) (test #'char=))  ;; Splits the string into substrings at spaces.  (let ((len (length string))	(index 0) result)    (dotimes (i len		(progn (unless (= index len)			 (push (subseq string index) result))		       (reverse result)))      (when (funcall test (char string i) item)	(unless (= index i);; two spaces in a row	  (push (subseq string index i) result))	(setf index (1+ i))))))(defun format-justified-string (prompt contents &optional (width 80)				       (stream *standard-output*))  (let ((prompt-length (+ 2 (length prompt))))    (cond ((< (+ prompt-length (length contents)) width)	   (format stream "~%~A- ~A" prompt contents))	  (t	   (format stream "~%~A-" prompt)	   (do* ((cursor prompt-length)		 (contents (split-string contents) (cdr contents))		 (content (car contents) (car contents))		 (content-length (1+ (length content)) (1+ (length content))))	       ((null contents))	     (cond ((< (+ cursor content-length) width)		    (incf cursor content-length)		    (format stream " ~A" content))		   (t		    (setf cursor (+ prompt-length content-length))		    (format stream "~%~A  ~A" prompt content)))))))  (finish-output stream))(defun number-to-string (number &optional (base 10))  (cond ((zerop number) "0")	((eql number 1) "1")	(t	 (do* ((len (1+ (truncate (log number base)))) 	       (res (make-string len))	       (i (1- len) (1- i))	       (q number)		; quotient	       (r 0))			; residue	     ((zerop q)			; nothing left	      res)	   (declare (simple-string res)		    (fixnum len i r))	   (multiple-value-setq (q r) (truncate q base))	   (setf (schar res i) 		 (schar "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ" r))))))(defun null-string (string &optional (start 0) end)  "Returns T if STRING is the null string \"\" between START and END."  (unless end (setf end (length string)))  (string-equal string "" :start1 start :end1 end));;;; ********************************;;;; Time ***************************;;;; ********************************(defun time-string (&optional universal-time)  (unless universal-time (setf universal-time (get-universal-time)))  (multiple-value-bind (secs min hour date month year dow)      (decode-universal-time universal-time)    (format nil "~@:(~A ~A-~A-~A ~2,'0d:~2,'0d:~2,'0d~)"	    (svref '#("Mon" "Tue" "Wed" "Thu" "Fri" "Sat" "Sun") dow)	    date 	    (svref '#(0 "Jan" "Feb" "Mar" "Apr" "May"			"Jun" "Jul" "Aug" "Sep" "Oct"			"Nov" "Dec")		   month)	    (mod year 100)	    hour min secs)));; miller;; This function was inspired by a similar function on the Symbolics;; lisp machine, which was used in the Rhet system. In fact, if we are;; on a symbolics, use that one. It will return more values, but;; that's ok. Plus we get the input editor "for free :-)" collect the;; characters until we hit a delimiter or eof, then turn it into a;; string and return!#-SYMBOLICS(DEFUN READ-DELIMITED-STRING (DELIMITERS &OPTIONAL (STREAM *STANDARD-INPUT*) (EOF-ERROR-P T) EOF-VALUE)  "Read a stream until one of the delimiters (a list of characters) isfound. Returns the characters so read until the delimiter as a string,plus the additional values: EOF-VALUE, which is as passed if eof wasreached, and the delimiter that caused termination of the string. IfEOF-ERROR-P is non-nil (the default), then an EOF causes an error tobe signalled instead of returning EOF-VALUE."  (DECLARE (TYPE LIST DELIMITERS)	   (TYPE STREAM STREAM))  (LET (CHAR-LIST)    (DECLARE (DYNAMIC-EXTENT CHAR-LIST))    (DO ((READ-CHAR (READ-CHAR STREAM EOF-ERROR-P :EOF) (READ-CHAR STREAM EOF-ERROR-P :EOF)))	((OR (MEMBER READ-CHAR DELIMITERS) (EQ READ-CHAR :EOF))	 (VALUES (COERCE (NREVERSE CHAR-LIST) 'STRING)                 (IF (EQ READ-CHAR :EOF) EOF-VALUE) READ-CHAR))      (PUSH READ-CHAR CHAR-LIST))));;; the following is contributed by baldwin@cs.geneseo.edu(defun Force-String (Thing)  "Generates a string representation of Thing. This representationis the print name for symbols, otherwise whatever 'coerce' can do (which maybe to generate an error sometimes)."  (cond    ((symbolp Thing)  (symbol-name Thing))    (t  (coerce Thing 'string))))